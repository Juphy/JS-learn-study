### 浏览器的内部机制
现代浏览器通常有两个重要的线程组成，这两个线程一起工作完成绘制页面的任务：
- 主线程
- 合成线程

主线程的任务：
- 运行Javascript
- 计算HTML元素的CSS样式
- layout (relayout)
- 将页面元素绘制成一张或多张位图
- 将位图发送给合成线程

合成线程的任务：
- 利用GPU将位图绘制到屏幕上
- 让主线程将可见的或即将可见的位图发给自己
- 计算哪部分页面是可见的
- 计算哪部分页面是即将可见的（当你的滚动页面的时候）
- 在你滚动时移动部分页面

长时间执行Javascript或者渲染一个很大的元素会阻塞主线程，在这期间，它将无法响应用户的交互，相反，合成线程则会尽量去响应用户的交互。当一个页面发生变化时，合成线程会以每秒60帧的间隔不断去重绘这个页面，即使这个页面不完整。

### GPU
GPUs擅长的事情：
- 1、绘制东西到屏幕上
- 2、一次次绘制同一张位图到屏幕上
- 3、绘制同一张位图到不同的位置、旋转角度和缩放比例
GPUs很不擅长的事情：
- 加载位图到内存中

### transition: height
一个元素的height从100px变成200px
```
div{
    height: 100px;
    transition: height 1s linear;
}

div:hover{
    height: 200px;
}
```

主线程和合成线程将按照下面的流程图执行相应的操作。注意在橘黄色方框的操作可能会比较耗时，在蓝色框中的操作是比较快速的。

![流程示意图](http://ww1.sinaimg.cn/large/8b2b1aafly1ftghup4v72j20qm153wgt.jpg)

在动画的每一帧中，浏览器都要执行布局、绘制、以及将新的位图提交给GPU。但是，将位图加载到GPU的内存中是一个相对较慢的操作。

浏览器需要做大量工作的原因在于每一帧中的元素的内容都在不断改变，改变一个元素的高度可能导致需要同步改变它的子元素的大小，所以浏览器必须重新计算布局。布局完成后，主线程又必须重新生成该元素的位图。

### transition: transform
使用CSS transform属性完成缩放
```
div{
    transform: scale(0.5);
    transition: transform 1s linear;
}
div:hover{
    transform: scale(1.0);
}
```
![流程图](http://ww1.sinaimg.cn/large/8b2b1aafly1ftjtur5tm0j20qm0xlgni.jpg)

css的transform属性不会改变元素本身的布局和周围元素的布局。它对元素的影响是整体作用——他整体缩放元素、整体旋转元素或者整体移动元素。浏览器只需要在动画开始的时候生成元素的位图并更新到GPU。之后，浏览器不需要做任何渲染、绘制或位图更新。相反浏览器可以利用GPU的特殊能力将相同的位图在不同的位置快速渲染，旋转，缩放。

### 总结
是否意味不能动画改变元素的高度？如果元素是孤立的，并不会引起页面其他部分的渲染，或者元素重排起来很简单，浏览器可以快速完成。css属性中动画执行效率搞得属性包括：
CSS transform
CSS opacity
CSS filter