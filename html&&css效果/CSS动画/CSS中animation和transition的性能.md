### 浏览器的内部机制
现代浏览器通常有两个重要的线程组成，这两个线程一起工作完成绘制页面的任务：
- 主线程
- 合成线程

主线程的任务：
- 运行Javascript
- 计算HTML元素的CSS样式
- layout (relayout)
- 将页面元素绘制成一张或多张位图
- 将位图发送给合成线程

合成线程的任务：
- 利用GPU将位图绘制到屏幕上
- 让主线程将可见的或即将可见的位图发给自己
- 计算哪部分页面是可见的
- 计算哪部分页面是即将可见的（当你的滚动页面的时候）
- 在你滚动时移动部分页面

长时间执行Javascript或者渲染一个很大的元素会阻塞主线程，在这期间，它将无法响应用户的交互，相反，合成线程则会尽量去响应用户的交互。当一个页面发生变化时，合成线程会以每秒60帧的间隔不断去重绘这个页面，即使这个页面不完整。

### GPU
GPUs擅长的事情：
- 1、绘制东西到屏幕上
- 2、一次次绘制同一张位图到屏幕上
- 3、绘制同一张位图到不同的位置、旋转角度和缩放比例
GPUs很不擅长的事情：
- 加载位图到内存中

### transition: height
一个元素的height从100px变成200px
```
div{
    height: 100px;
    transition: height 1s linear;
}

div:hover{
    height: 200px;
}
```

主线程和合成线程将按照下面的流程图执行相应的操作。注意在橘黄色方框的操作可能会比较耗时，在蓝色框中的操作是比较快速的。

![流程示意图](http://ww1.sinaimg.cn/large/8b2b1aafly1ftghup4v72j20qm153wgt.jpg)

在动画的每一帧中，浏览器都要执行布局、绘制、以及将新的位图提交给GPU。但是，将位图加载到GPU的内存中是一个相对较慢的操作。

浏览器需要做大量工作的原因在于每一帧中的元素的内容都在不断改变，改变一个元素的高度可能导致需要同步改变它的子元素的大小，所以浏览器必须重新计算布局。布局完成后，主线程又必须重新生成该元素的位图。

### transition: transform
使用CSS transform属性完成缩放
```
div{
    transform: scale(0.5);
    transition: transform 1s linear;
}
div:hover{
    transform: scale(1.0);
}
```
![流程图](http://ww1.sinaimg.cn/large/8b2b1aafly1ftjtur5tm0j20qm0xlgni.jpg)

css的transform属性不会改变元素本身的布局和周围元素的布局。它对元素的影响是整体作用——他整体缩放元素、整体旋转元素或者整体移动元素。浏览器只需要在动画开始的时候生成元素的位图并更新到GPU。之后，浏览器不需要做任何渲染、绘制或位图更新。相反浏览器可以利用GPU的特殊能力将相同的位图在不同的位置快速渲染，旋转，缩放。

### 总结
是否意味不能动画改变元素的高度？如果元素是孤立的，并不会引起页面其他部分的渲染，或者元素重排起来很简单，浏览器可以快速完成。css属性中动画执行效率高得属性包括：
CSS transform
CSS opacity
CSS filter
这是因为并不是所有的CSS属性都能触发GPU的硬件加速，实际上只有少数属性可以。

### 硬件加速的工作原理
浏览器接收到页面文档后，会将文档中的标记语言解析为DOM树，DOM树和CSS结合后形成浏览器构建页面的渲染树。渲染树中包含了大量的

### 强制使用GPU渲染
为了避免2D transform 动画在开始和结束时发生的repaint操作，我们可以硬编码一些样式来解决这个问题：
```
.example1 {
    transform: translateZ(0);
}
.example2 {
    transform: rotateZ(360deg);
}
```
这段代码的作用是让浏览器执行3D transform，浏览器通过该样式创建了一个独立图层，图层中的动画则有GPU进行预处理并且触发了硬件加速。

如果一个元素的背后是一个复杂元素，那么该元素的repaint操作就会消耗大量的资源，此时也可以使用上面的技巧来减少性能开销，