### Manacher
- 在原字符串的每个相邻两个字符中间插入一个分隔符，同时在首尾也要添加分隔符，分隔符的要求是不在原串中出现，一般情况下可以用#号
- 辅助数组Len[i]表示以字符s[i]为中心的最长回文串的最右字符到s[i]的长度，比如以s[i]为中心的最长回文串是s[left, right]，那么Len[i] = right - i +1，相当于回文串的半径。
```
原串S：aaaba
       T：#a#a#a#b#a#
  Len ：12343214121

Len数组的一个性质就是Len[i] - 1就是该回文串在原字符串s中的长度，在转换得到的字符串T中，所有的回文串的长度都是奇数，那么对于以T[i]为中心的最长回文串，其长度就为2*Len[i]-1，T中所有的回文子串，其中分隔符的数量一定比其他字符的数量多1，也就是Len[i]个分隔符，剩下Len[i]-1个字符来自原字符串，所以该回文串在原字符串中的长度就为Len[i]-1;
```
- Len数组的计算：当Len[i]计算时，Len[j]`(`0<=j`<`i)已经计算完毕。设P为之前计算中最长回文子串的右端点的最大值，并且设取得这个最大值的位置为po，分为两种情况：

i`<=`p：那么找到i相对于po的对称位置，设为j，那么如果Len[j]<p-i,

![picture1](https://http://wx1.sinaimg.cn/mw690/8b2b1aafly1g5s4eygxanj21sb0u00ys.jpg)

那么就说明以j为中心的回文串一定在以po为中心的回文串的内部，且j和i关于位置po对称，由回文串的定义可知，以 i为中心的回文串的长度至少和以j为中心的回文串一样，即Len[i] = Len[j]。因为Len[j] < p-i，所以i+Len[j]<p。
如果




