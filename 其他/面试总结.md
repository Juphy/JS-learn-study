### 盒模型

W3C 标准盒模型，IE 怪异盒模型

### 元素的类型

块级元素：独占一行，可设置宽高，可包含块级元素和行内元素。
行内元素：与其它行内元素在一行，不能设置宽高，宽高有内容支撑，行内元素只能包含行内元素，可设置内边距 padding，水平方向上的外边距 margin
行内块级元素：综合块级元素和行内元素的特性，可设宽高，也可设内外边距。

### 常见的定位方案

普通流：元素按照 HTML 中的先后位置至上而下布局，行内元素水平布局，直到当行占满然后换行，块级元素占满行
浮动：元素首先按照普通流的位置出现，然后根据浮动的方向极可能向左或向右偏移。
绝对定位：absolute

### BFC

BOX 是 CSS 的布局的对象和基本单位。元素的类型和属性决定了 BOX 的类型。
块级格式化上下文，是一个独立的渲染区域，让处于 BFC 内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。
触发条件：根元素、position: absolute/fixed、float 元素、display 的值是 inline-block、table-cell、flex、table-caption 或者 inline-flex、overflow 的值不是 visible
规则：1.属于同一个 BFC 的 box，会垂直排列
2.BOX 垂直方向上的距离由 margin 决定，同一个 BFC 相邻的 box 的 margin 会重叠。
3.BFC 中的每一个子元素的 margin 的左边，与 BFC 的 border 的左边相接触（absolute 除外）
4.BFC 的区域不会与浮动元素区域重叠 5.计算 BFC 的高度时，浮动子元素也要参与计算 6.文字层不会被浮动层覆盖，环绕其周围
应用：1.阻止 margin 重叠 2.清除浮动 3.自适应两栏布局 4.阻止元素被浮动元素覆盖

根元素(html)，浮动，display: inline-block, flex, table, position: absolute fixed, overflow 不是 visible

### 层叠上下文

触发条件：

- 根层叠上下文(html)
- position
- css3 属性：
  - flex
  - transform
  - opacity
  - filter
  - will-change
  - -webkit-overflow-scrolling
background/border < z-index 负值 < 块级元素、浮动元素、行内元素 < z-index=0 < z-index 正值

### 居中布局

- 水平居中
  - 行内元素: text-align:center
  - 块级元素: margin: 0 auto
  - absolute+transform(或者 left:50%;margin-left: -50%自身)
  - flex,justify-content: center
- 垂直居中
  - line-height:height
  - absolute+transform(或者 top：50%;margin-top: -50%自身)
  - flex, align-item: center
  - table
- 水平垂直居中
  - absolute+transform(left,top,margin-left,margin-top)
  - flex,justify-content/align-items

### 选择器优先级

!important > 行内样式 > #id > class > tag > \* > 继承 > 默认

### 去除浮动

- 通过增加尾元素清除浮动:after{ clear: both }
- 设置父级 BFC
- 父级设置高度

### link 与@import 的区别

- `link`功能较多，可以定义 RSS，定义 Rel 等作用，而`@import`只能用于加载 css
- 当解析到`link`时，页面会同步加载所引的 css，而`@import`所引用的 css 会等到页面加载完成才被加载
- `@import`需要 IE5 以上才能使用
- `link`可以使用 js 动态引入，`@import`不行

### css 预处理器（Sass/Less/Postcss）

将类 CSS 语言通过 WebPack 编译转成浏览器可读的真正的 CSS。在这层编译之上，便可以赋予 CSS 更多更强大的功能，常用功能：

- 嵌套
- 变量
- 循环语句
- 条件语句
- 自动前缀
- 单位转换
- mixin 复用

### CSS 动画

- transition: 过渡动画

  - transition-property: 属性
  - transition-duration: 间隔
  - transition-timing-function: 曲线
  - transition-delay: 延迟
  - 常用钩子: transitionend

- animation / keyframes
  - animation-name: 动画名称，对应`@keyframes`
  - animation-duration: 间隔
  - animation-timing-function: 曲线
  - animation-delay: 延迟
  - animation-iteration-count: 次数
    - infinite: 循环动画
  - animation-direction: 方向
    - alternate: 反向播放
  - animation-fill-mode: 静止模式
    - forward: 停止时，保留最后一帧
    - backwards: 停止时，回到第一帧
    - both: 同时运用 forwards / backwards
  - 常用钩子: animationend
- 动画属性：尽量使用动画属性进行动画，能拥有较好的性能表现
  - translate
  - scale
  - rotate
  - skew
  - opacity
  - color

### 原型/构造函数/实例

原型（prototype）: 一个简单的对象，用于实现对象的属性继承。每个 JavaScript 对象都包含一个`__proto__`的属性指向该对象的原型，可`obj.__proto__`进行访问
构造函数：可以通过 new 来新建一个对象的函数
实例：通过构造函数和 new 创建出来的对象就是实例。`实例通过__proto__指向原型，通过constructor指向构造函数。`

```
实例.__proto__ = 原型
原型.constructor = 构造函数 ==> 实例.constructor = 构造函数
构造函数.prototype = 原型

原型.__proto__ = Object.prototype
构造函数.__proto__ = Function.prototype
Function.prototype.__proto__ = Object.prototype

let a = {};
a.constructor === Object  // true
a.__proto__ = null;
a.constructor === Object  // false
```

### 原型链

原型链是由原型对象组成，每个对象都有`__proto__`属性，指向了创建该对象的构造函数的原型，`__proto__`将对象连接起来组成了原型链，是一个用来实现继承和共享属性的有限的对象链。

- 属性查找机制：当查找对象的属性时，如果实例对象自身不存在该属性，则沿着原型链往上一级查找，找到时则输出，不存在时，则继续沿着原型链往上一级查找，直至最顶级的原型对象 Object.prototype 如果还是没找到，则输出 undefined

- 属性修改机制：只会修改实例对象本身的属性，如果不存在，则进行添加该属性，如果需要修改原型的属性时，则可以用 b.prototype.x = 2,但是会造成继承于该对象的实例的属性发生变化

### 执行上下文

执行上下文可以理解成一个对象：

- 包含三个部分：变量对象，作用域链，this 指向
- 类型：全局执行上下文，函数执行上下文，eval 指向上下文
- 代码执行过程：
  - 创建全局上下文(global EC)
  - 全局执行上下文(caller)逐行自上而下执行，遇到函数时，函数执行上下文(callee)被`push`到执行栈顶层
  - 函数执行上下文被激活，成为 active EC，开始执行函数中的代码，caller 被挂起
  - 函数执行完后，callee 被`pop`移除执行栈，控制权交还全局上下文（caller），继续执行

### 闭包

在 js 中，一个函数中的内部函数，可以访问外部函数的变量，当通过外部函数返回一个内部函数时，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，把这些变量的集合称为闭包。

产生的问题：多个内部函数同时指向外部函数，是完全共享的，当外部函数中的变量发生变化，所有这种函数都会受到影响。

解决：1. 变量可以通过函数传参的形式传入 2. 使用 setTimeout 包裹，通过第三个参数传入 3. 使用块级作用域，让变量成为自己上下文的属性，避免共享

### script 引入方式

- html 静态`<`script`>`引入
- js 动态插入`<script>`
- `<script defer>` 延迟加载，元素解析完成后执行
- `<script async>` 异步加载，但执行时会阻塞元素渲染

### 对象的拷贝

浅拷贝：以赋值的形式拷贝引用的对象，仍然指向同一地址，修改时原对象也会受到影响

- Object.assign()
- 扩展运算符{...}

深拷贝：完全拷贝一个新对象，修改时原对象不再受到任何影响

- JSON.parse(JSON.stringify(obj))
  - 循环引用的对象时，报错
  - 当值为函数、undefined、或 symbol 时，无法拷贝
- 递归逐一赋值 Array Object

### new 运算符的执行过程

- 新生成一个对象
- 链接到原型：obj.`__proto__` = constructor.prototype
- 绑定 this: `apply`
- 返回新对象（如果构造函数有自己 return 时，则返回该值）

### instanceof 原理

能在实例的原型对象链中找到该构造函数的`prototype`属性所指向的原型对象，就返回 true

```
// __proto__: 代表原型对象链
instance.[__proto__...] === instance.constructor.prototype

// return true
```

### 代码的复用

- 函数封装
- 继承
- 复制 `extend`
- 混入 `mixin`
- 借用 `apply/call`

> 在 JS 中，继承通常指的是原型链继承，也就是通过指定原型，并通过原型链继承原型上的属性或者方法

- 圣杯模式: 当需要让多个构造函数公用一个原型时，需要在某个构造函数中增加一个私有属性时

```
var inherit = (function(){
  var F= function(){}; // 中间层
  return function(target, origin){
    F.prototype = origin.prototype; // 共享原型
    target.prototype = new F(); //  constructor
    target.constructor = target; // 修改constructor指向
    target.prototype.uber = origin.prototype;
  }
})();
```

- class / extends

```JavaScript
class Point{

}

class ColorPoint extends Point{
  constructor(x, y, color){
    super(x, y); // 调用父类的constructor(x, y);
    this.color = color;
  }

  toString(){
    return this.color + ' ' + super.toString(); // 调用父类的toString()
  }
}
```

ES5 的继承，实质是先创造子类的实例对象`this`,然后再将父类的方法添加到`this`上面。ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到`this`上面（所以必须先调用`super`方法），然后在用子类的构造函数修改`this`。如果子类没有定义 constructor 方法，这个方法会被默认添加。在子类的构造函数中，只有调用`super`之后，才可以使用`this`关键字，否则会报错，这是因为子类实例的构建，基于父类实例，只有`super`方法才能调用父类实例。

### 类型转换

- -、\*、/、%：四则运算一律转换成数值后计算
- +：
  - 数字 + 字符串 = 字符串， 运算顺序是从左到右
  - 数字 + 对象， 优先调用对象的 valueOf -> toString
  - 数字 + boolean/null -> 数字
  - 数字 + undefined -> NaN
- `[1]`.toString() === '1'
- {}.toString() === '[object object]'
- NaN !== NaN +undefined 为 NaN

### 类型判断

- 基本类型（null）: String(null) === 'null'
- 基本类型(string boolean undefined number) + function: 直接使用`typeof`
- 其余引用类型（Array Date RegExp Error）: Object.prototype.toString.call() "[`object Array`]"

```JavaScript
let class2type = {}
'Array Date RegExp Object Error'.split(' ').forEach(e => class2type[ '[object ' + e + ']' ] = e.toLowerCase())

function type(obj) {
    if (obj == null) return String(obj)
    return typeof obj === 'object' ? class2type[ Object.prototype.toString.call(obj) ] || 'object' : typeof obj
}

```

### 模块化

在浏览器中使用 ES6 的模块化支持，在 Node 中使用 commonjs 的模块化支持。

1. 分类：

- es6: `import / export`
- commonjs: `require / module.exports / exports`
- amd: `require / defined`

2. require 和 import 的区别

- require 支持`动态导入`, import 不支持
- require 是同步导入 import 属于异步导入
- require 是值拷贝，导出值变化不会影响导入值，import 指向内存地址，导入值会随导出值而变化

### 防抖和节流：高频触发额优化方式

### 函数执行改变 this

由于 JS 的设计原理：在函数中，可以引用的运行环境的变量，因此需要一个机制来让我们可以在函数体内部获取当前的运行环境，这便是`this`

- `obj.fn()`: obj 调用了函数，函数中的 this 就是 obj
- `fn()`: window.fn() 因此 this === window

修改 this:

- call: fn.call(this, 1, 2, 3)
- apply: fn.apply(this, `[1,2,3]`)
- bind: fn.bind(this)(1, 2, 3) 返回绑定好的函数不立即执行

### ES6/ES7

1. 声明

- `let / const`: 块级作用域 不存在变量提升 暂时性死区 不允许重复声明
- const：常量声明，无法修改

2. 解构赋值
3. class / extend: 类声明与继承
4. Set / Map
5. 异步解决方案

- Promise
- generator
  - yield: 暂停代码
  - next(): 继续执行代码
- await / async: generator 的语法糖，babel 中基于 promise 实现

### AST(抽象语法树 Abstract Syntax Tree)

将代码逐字母解析成`树状对象`的形式，这是语言之间的转换、代码语法检查、代码风格检查、代码格式化、代码高亮、代码错误提示、代码自动补全等等的基础。
一种编程语言的源代码，通过构建语法树的形式将源代码中的语句映射到树中的每一个节点上。
在 JavaScript 中，JS 引擎会把源代码转换成 AST，解释器再基于 AST 生成字节码，提供给计算机。
JS 引擎中还有优化编译器，它会花费更多的时间处理 AST，生成优化后的机械码(比解释器 interpreter 生成的字节码更高效)。
抽象语法树作用：编译器、IED、压缩优化代码等，在 JavaScript 中，虽然不直接用，但经常涉及，例如在使用 UglifyJS 来压缩代码或 babel 转换代码，实际这背后就是在对 JavaScript 的抽象语法树进行操作

Babel AST:@babel/parser: babel 解析语法树，内部采用的是@babel/parser 包，它依赖于 acorn，生成的语法树遵守 estree 规范

### Babel 的编译原理

核心包：

- babel-core：babel 转译器本身，提供了 babel 的转译 API，如 babel.transform 等，用于对代码进行转译。像 webpack 的 babel-loader 就是调用这些 API 来完成转译过程的。
- babylon：js 的词法解析器
- babel-traverse：用于对 AST（抽象语法树，想了解的请自行查询编译原理）的遍历，主要给 plugin 用
- babel-generator：根据 AST 生成代码

1. ES6 通过 babylon 进行解析成 AST
2. plugin 用 babel-traverse 对 AST 进行遍历转译，得到新的 AST
3. 新 AST 通过 babel-generator 转换成 ES5

### 函数柯里化

在一个函数，首先填充几个参数，然后在返回一个新的函数的技术，成为函数的柯里化。通常可用于在不入侵函数的前提下，为函数`预置通用参数`，供多次重复调用。

```
const add = function add(x) {
	return function (y) {
		return x + y
	}
}

const add1 = add(1)

add1(2) === 3
add1(20) === 21
```

作用：参数复用，提前确认，延迟运行

```JavaScript
Function.prototype.bind = function(context){
  var _this = this;
  var args = Array.prototype.slice.call(arguments, 1);
  return function(){
    return _this.apply(context, args);
  }
}
```

### 数组

- map
- forEach: 无法 break 可以用 try/catch 中 throw new Error
- filter
- some
- every
- join
- push/pop
- unshift/shift
- sort(fn)/reverse
- concat 浅拷贝
- slice(start, end)
- splice(start, number, value) 返回删除元素组成的数组
- indexOf/lastIndexOf(value, fromIndex) 查找数组项，返回对应的下标，fromIndex 开始查找的索引值，从左或者从右
- reduce/reduceRight
- flat

```JavaScript
Array.prototype.flat = function(){
  return this.toString().split(',').map(item => +item);
}
```

## 浏览器

### 跨标签页通讯

不同标签页间的通讯，本质原理就是去用一些可以共享的中间介质

- 通过父页面`window.open()`和子页面`postMessage`
  - 异步下，通过`window.open('about: blank')`和`tab.location.href="*"`
- 设置同域下共享的`localStorage`与监听`window.onStorage`
  - 重复写入相同的值无法触发
  - 会受到浏览器隐身模式等的限制
- 设置共享`cookie`与不断轮询脏值检查（setInterval）
- 借助服务端或者中间层实现

### 浏览器架构
- 用户界面
- 主进程
- 内核
  - 渲染引擎
  - JS引擎
    - 执行栈
  - 事件触发线程
    - 消息队列
      - 微任务
      - 宏任务
  - 网络异步线程
  - 定时器线程

### 浏览器下事件循环
事件循环指的是：执行一个宏任务，然后执行清空微任务列表，循环再执行宏任务，在清空微任务列表
- 微任务: promise().then() await/async mutation 
- 宏任务 macrotask(task): setTimout / script / IO / UI Rendering

### 从输入URL到展示的过程
- DNS解析
- TCP三次握手
- 发送请求，分析URL，设置请求报文
- 服务器返回请求的文件
- 浏览器渲染
  - html解析DOM树 CSS解析CSSOM树
  - DOM树和CSSOM树形成渲染树
