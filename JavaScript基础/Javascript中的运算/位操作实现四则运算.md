### 加法

二进制的加法用位运算替代，对于异或而言，0 和 0、1 和 1 异或的结果都是 0，而 0 和 1、1 和 0 的异或结果是 1；对 0 加 0、1 加 0、0+1 而言都不会产生进位，只有 1 加 1 时，会向前产生一个进位

```
1 + 1 = 0
1 + 0 = 1
0 + 1 = 1
0 + 0 = 0
=> 执行加法
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 1 = 1
0 ^ 0 = 0

0 + 0 = 0
1 + 0 = 0
0 + 1 = 0
1 + 1 = 1
=> 执行进位
0 & 0 = 不进位
1 & 0 = 不进位
0 & 1 = 不进位
1 & 1 = 进位
```

> 递归有限步结束的证明

因为每步的和都可分解为两个部分，一个异或值（记为 A)，一个与值（记为 B)。
第 n+1 步与第 n 步相比：
B 的二进制表示中 1 的个数是不增的（由与的性质可知）。countTrueBits(B(n+1)) <= countTrueBits(B(n))
另外，B(n)一直在左移，并且 B 的 bit 数有限，故二进制 1 的个数不可能一直保持不变，因此只能越来越少。最后终止在有限步

> 求 1+2+…+n，要求不能使用乘除法、for、while、if、else、switch、case 等关键字以及条件判断语句（A?B:C）

定义两个函数，一个函数充当递归函数的角色，另一个函数处理终止递归的情况。在两个函数里二选一，使用布尔变量，true(1)的时候调用第一个函数，false(0)的时候调用第二个函数。

```
此方法容易造成栈溢出。。。
let sum = (n) => {
    return n && n + sum(n - 1);
}
```

### 减法

`[x-y]补`=`[x]补`-`[y]补`=`[x]补`+`[-y]补`

从`[y]补`求`[-y]补`的法则是：对`[y]补`包括符号位求反且末位加 1，即可得到`[-y]补`。

### 乘法

```
        1 1 1   7
        1 0 1   5
======
        1 1 1
     0 0 0
  1 1 1
======
10 0 0 1 1
```

a \* b：从 b 的第 1 位开始，如果第 1 位为 1，则加上 a(111)，接着第二位，如果为 0，不加，不为 0 则加 1110，第三位为 1，则加 11100。b 每向右移一位，a 的值就要像左移动。

### 除法
除法就是由乘法的过程逆推，依次减掉（如果x够减）
y^(2^31),y^(2^30),...y^4,y^2,y^1.减掉相应数量的y就在结果加上相应的数量。