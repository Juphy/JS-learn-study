### 负数以其正值的补码形式表达

数值位就是真值的绝对值，符号位位"0"时表示正数，符号位为"1"时表示负数，原码又称带符号的绝对值。为了方便整数和小数区别，整数的符号位与数值位之间用","隔开，小数的符号位与数值位之间用"."隔开。


`原码`：一个整数，按照绝对值大小转换成的二进制数，称为原码

```
int类型的数字占用4个字节（32位）
5的原码：00000000 00000000 00000000 00000101
```

`反码`：将二进制数按位取反，所得的新二进制数称为原二进制数的反码
取反操作就是原为 1，得 0；原为 0，得 1。

00000000 00000000 00000000 00000101 取反得 11111111 11111111 11111111 11111010，两者互为反码。

`补码`：反码加 1 称为补码。正数的补码就是原码
补码就是 11111111 11111111 11111111 11111010 + 1 = 11111111 11111111 11111111 11111011

因此 -5 在计算机中的表达式为 11111111 11111111 11111111 11111011。

在计算机系统中，数值一律用补码来表示和存储，原因在于使用补码，可以将符号位和数值域统一处理。

### Two's Complement

（以下在 8 位机中，规定每个字节的最高位为符号位）。
负数使用 Two's Complement 表示。
2 的补码，它是一种数值的转换方法，分为两步：

- 每一个二进制位都取相反值，0 变成 1，1 变成 0。
- 将上一步得到的值加 1。

以-8 为例：8 的原码为 00001000，-8 表示为 10001000 或者 11111000。

```
16+(-8) =>

    00010000
    10001000
--------------
    10011000
```

如果按照正常的加法规则，就会得到 10011000 的结果，转为十进制就是-24，显然这不是想要的答案，使用 2 的补码，

```
16+(-8) =>
    00010000
    11111000
--------------
  100001000
```

100001000 是一个 9 位的二进制数，已经假定是一台 8 位机，因此最高的第 9 位是一个溢出位，会被自动舍去，所以结果就变成了 00001000，转成十进制正好是 8。这就说明 2 的补码表示法可以将加法运算法则，扩展到整个整数集。

`Two's Complement`的本质：
要将正数转成对应的负数，其实只要用 0 减去这个数就可以了，-8 其实就是 0-8。

```
0-8  =>
  100000000
    00001000
-------------
    11111000
=>
    11111111
    00001000
--------------
    11110111
    00000001
--------------
    11111000
```

因为 00000000 小于 00001000，所以需要向上借一位，也就是 100000000-00001000，而 100000000=1111111+1，所以 2 的补码就是这么来的。

### 为什么正数加法适用于 2 的补码？

实际上，证明的是 X-Y 或 X+(-Y)可以用 X 加上 Y 的 2 的补码即可。

Y 的 2 的补码等于(11111111-Y)+1，所以 X 加上 Y 的 2 的补码，就等同于：X+(11111111-Y)+1
假定Z，Z=X
Z = X + (11111111-Y) + 1式子可以写为Z = X - Y +100000000，这在硬件上可以理解为两部分电路来实现，第一部分是前面的X - Y（这里姑且不管计算的结果是正还是负），第二部分是X - Y计算的结果再和100000000相加，最终得到计算的结果Z, 而在8位的计算机上100000000是不能出现的，其实这时100000000就相当于00000000（舍去了最高位），然后我们再看一些计算的过程：
Z = X + （11111111 - Y) + 1
= X - Y + 100000000
= X - Y + 00000000
= X - Y
证毕。