
> 0.7*180===125.99999999999999

> [0.1+0.2===0.30000000000000004](http://0.30000000000000004.com/)

> 1000000000000000128 === 1000000000000000129

JS仅有Number这个数值类型，而Number采用的是IEEE 754 64位双精度浮点数编码。而浮点数表示方式具有以下特点：
- 1.浮点数可表示的值范围比同等位数的整数表示方式的值范围要大得多
- 2.浮点数无法精确表示其值范围内的所有数值，而有符号和无符号整数则是精确表示其值范围内的每个数值
- 3.浮点数只能精确表示 m*2^e 的数值
- 4.当biased-exponent为2e-1-1时，浮点数能精确表示该范围内的各整数值
- 5.当biased-exponent不为2e-1-1时，浮点数不能精确表示该范围内的各整数值

*0.1 + 0.2 === 0.30000000000000004，不仅是JavaScript会产生这种问题，只要是采用IEEE 754 Floating-point的浮点数编码方式来表示浮点数时，则会产生这类问题。下面我们来分析整个运算过程：*

1. 0.1 的二进制表示为 1.1001100110011001100110011001100110011001100110011001 1(0011)+ * 2^-4
2. 当64bit的存储空间无法存储完整的无限循环小数，而IEEE 754 Floating-point采用round to nearest, tie to even的舍入模式，因此0.1实际存储时的位模式是0-01111111011-1001100110011001100110011001100110011001100110011010
3. 0.2 的二进制表示为 1.1001100110011001100110011001100110011001100110011001 1(0011)+ * 2^-3
4. 当64bit的存储空间无法存储完整的无限循环小数，而IEEE 754 Floating-point采用round to nearest, tie to even的舍入模式，因此0.2实际存储时的位模式是0-01111111100-1001100110011001100110011001100110011001100110011010
5. 实际存储的位模式作为操作数进行浮点数加法，得到 0-01111111101-0011001100110011001100110011001100110011001100110100。转换为十进制即为0.30000000000000004

*Why 0.7 * 180===125.99999999998 ?*

1. 0.7实际存储时的位模式是0-01111111110-0110011001100110011001100110011001100110011001100110
2. 180实际存储时的位模式是0-10000000110-0110100000000000000000000000000000000000000000000000
3. 实际存储的位模式作为操作数进行浮点数乘法，得到0-10000000101-1111011111111111111111111111111111111111101010000001。转换为十进制即为125.99999999998

*解决方法：*
```
function numAdd(num1/*:String*/, num2/*:String*/) {
    var baseNum, baseNum1, baseNum2;
    try {
        baseNum1 = num1.split(".")[1].length;
    } catch (e) {
        baseNum1 = 0;
    }
    try {
        baseNum2 = num2.split(".")[1].length;
    } catch (e) {
        baseNum2 = 0;
    }
    baseNum = Math.pow(10, Math.max(baseNum1, baseNum2));
    return (num1 * baseNum + num2 * baseNum) / baseNum;
};
```






