## 函数防抖
任务频繁触发时，只有在任务触发的间隔超过指定间隔的时候，任务才会执行。事件被触发n秒后在执行回调函数，如果在这n秒内又被触发，则重新记时。

类似于生活中的坐电梯事件（如果有人进电梯（触发事件），那电梯将在10秒钟后出发（执行事件监听器），这时如果又有人进电梯了（在10秒内再次触发该事件），我们又得等10秒再出发（重新计时））。

防抖应用：（多次连续的事件一次响应）
- 按钮提交表单，连续点击进行ajax请求
- 输入框连续输入，自动进行ajax请求
- scroll、resize触发统计事件

```
function debounce(fn ,delay){
    let timer;
    return function(){
        clearTimeout(timer);
        timer = setTimeout(() =>{
            fn.apply(this, arguments)
        }, delay)
    }
}
```

## 函数节流
规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。

保证如果电梯第一个人进来后，10秒后准时运送一次，这个时间从第一个人上电梯开始计时，不等待，如果没有人，则不运行。

节流应用：（大量事件按时间做平均分配）
- 射击游戏中的mousedown和keydown事件（单位时间只能进行一次操作）
- DOM元素拖拽（mousemove）
- canvas模拟画板（mousemove）
- 搜索联想（keyup）
- 监听滚动事件判断是否到页面底部自动加载更多：给 scroll 加了 debounce 后，只有用户停止滚动后，才会判断是否到了页面底部；如果是 throttle 的话，只要页面滚动就会间隔一段时间判断一次。
